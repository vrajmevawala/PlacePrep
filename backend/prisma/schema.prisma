generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                Int               @id @default(autoincrement())
  fullName          String
  email             String            @unique
  password          String
  created_at        DateTime          @default(now())
  role              Role              @default(user)
  participations    Participation[]
  questions         Question[]        @relation("UserQuestions")
  studentActivities StudentActivity[]
  testSeries        TestSeries[]      @relation("UserTestSeries")
  freePractice      freePractice[]    @relation("UserFreePractice")
  bookmarks         Bookmark[]
  notifications     Notification[]
  resources         Resource[]        @relation("UserResources")
}

model Question {
  id                Int               @id @default(autoincrement())
  category          Category
  subcategory       String
  level             Level
  question          String
  options           Json
  correctAns        String
  explanation       String
  visibility        Boolean           @default(true)
  createdBy         Int
  created_at        DateTime          @default(now())
  author            User              @relation("UserQuestions", fields: [createdBy], references: [id])
  studentActivities StudentActivity[]
  freePractice      freePractice[]    @relation("FreePracticeQuestions")
  testSeries        TestSeries[]      @relation("TestSeriesQuestions")
  bookmarks         Bookmark[]
}

model TestSeries {
  id                Int               @id @default(autoincrement())
  createdBy         Int
  title             String
  startTime         DateTime
  endTime           DateTime
  requiresCode      Boolean           @default(false)
  contestCode       String?           @unique
  participations    Participation[]   @relation("TestSeriesParticipation")
  studentActivities StudentActivity[] @relation("TestSeriesToStudentActivity")
  creator           User              @relation("UserTestSeries", fields: [createdBy], references: [id])
  questions         Question[]        @relation("TestSeriesQuestions")
  level             Level?            // Made optional
}

model freePractice {
  id                Int               @id @default(autoincrement())
  createdBy         Int
  startTime         DateTime
  endTime           DateTime?
  category          Category
  level             Level?            // Made optional
  subcategory       String
  title             String
  participations    Participation[]   @relation("FreePracticeParticipation")
  studentActivities StudentActivity[] @relation("FreePracticeToStudentActivity")
  creator           User              @relation("UserFreePractice", fields: [createdBy], references: [id])
  questions         Question[]        @relation("FreePracticeQuestions")
}

model Participation {
  pid            Int           @id @default(autoincrement())
  sid            Int
  practiceTest   Boolean
  contest        Boolean
  testSeriesId   Int?
  freePracticeId Int?
  startTime      DateTime
  endTime        DateTime?
  freePractice   freePractice? @relation("FreePracticeParticipation", fields: [freePracticeId], references: [id])
  user           User          @relation(fields: [sid], references: [id])
  testSeries     TestSeries?   @relation("TestSeriesParticipation", fields: [testSeriesId], references: [id])
}

model StudentActivity {
  aid            Int           @id @default(autoincrement())
  sid            Int
  qid            Int
  time           DateTime
  selectedAnswer String?       @db.VarChar(255)
  testSeriesId   Int?
  freePracticeId Int?
  freePractice   freePractice? @relation("FreePracticeToStudentActivity", fields: [freePracticeId], references: [id], onDelete: Cascade)
  question       Question      @relation(fields: [qid], references: [id], onDelete: Cascade)
  user           User          @relation(fields: [sid], references: [id])
  testSeries     TestSeries?   @relation("TestSeriesToStudentActivity", fields: [testSeriesId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Activity {
  id        Int      @id @default(autoincrement())
  user      String
  action    String
  score     Int?
  timestamp DateTime @default(now())
}

model Bookmark {
  id         Int       @id @default(autoincrement())
  user       User      @relation(fields: [userId], references: [id])
  userId     Int
  question   Question? @relation(fields: [questionId], references: [id])
  questionId Int?
  resource   Resource? @relation(fields: [resourceId], references: [id])
  resourceId Int?
  createdAt  DateTime  @default(now())
  @@unique([userId, questionId])
  @@unique([userId, resourceId])
}

model Notification {
  id        Int           @id @default(autoincrement())
  userId    Int
  title     String
  message   String
  type      NotificationType
  isRead    Boolean       @default(false)
  data      Json?         // Additional data like contestId, resultId, etc.
  createdAt DateTime      @default(now())
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Resource {
  id          Int         @id @default(autoincrement())
  title       String
  description String?
  category    Category
  subcategory String?
  level       Level
  type        ResourceType
  fileUrl     String?     // For PDF files
  fileName    String?     // Original filename
  fileSize    Int?        // File size in bytes
  videoUrl    String?     // For video resources
  createdBy   Int
  createdAt   DateTime    @default(now())
  creator     User        @relation("UserResources", fields: [createdBy], references: [id])
  bookmarks   Bookmark[]
}

enum Category {
  Aptitude
  Technical
}

enum Level {
  easy
  medium
  hard
}

enum Role {
  user
  moderator
  admin
}

enum NotificationType {
  CONTEST_ANNOUNCED
  CONTEST_STARTED
  CONTEST_ENDED
  RESULT_AVAILABLE
  NEW_QUESTION
  SYSTEM_UPDATE
  GENERAL
}

enum ResourceType {
  MCQ
  PDF
  VIDEO
}